/**
 * This file is part of the TYPO3 CMS project.
 *
 * It is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, either version 2
 * of the License, or any later version.
 *
 * For the full copyright and license information, please read the
 * LICENSE.txt file that was distributed with this source code.
 *
 * The TYPO3 project - inspiring people to share!
 */
/**
 * HTMLArea.StatusBar extends Ext.Container
 */
HTMLArea.StatusBar = function (UserAgent, Dom) {

	var StatusBar = Ext.extend(Ext.Container, {

		/**
		 * Constructor
		 */
		initComponent: function () {
			StatusBar.superclass.initComponent.call(this);
			// Build the deferred word count update task
			this.updateWordCountLater = new Ext.util.DelayedTask(this.updateWordCount, this);
			this.addListener({
				render: {
					fn: this.addComponents,
					single: true
				},
				afterrender: {
					fn: this.initEventListeners,
					single: true
				}
			});
		},

		/**
		 * Initialize listeners
		 */
		initEventListeners: function () {
			this.addListener({
				beforedestroy: {
					fn: this.onBeforeDestroy,
					single: true
				}
			});
			// Monitor toolbar updates in order to refresh the contents of the statusbar
			// The toolbar must have been rendered
			this.mon(this.ownerCt.toolbar, 'HTMLAreaEventToolbarUpdate', this.onUpdateToolbar, this);
			// Monitor editor changing mode
			this.mon(this.getEditor(), 'HTMLAreaEventModeChange', this.onModeChange, this);
			// Monitor word count change
			this.mon(this.ownerCt.iframe, 'HTMLAreaEventWordCountChange', this.onWordCountChange, this);
		},

		/**
		 * editorId should be set in config
		 */
		editorId: null,

		/**
		 * Get a reference to the editor
		 */
		getEditor: function() {
			return RTEarea[this.editorId].editor;
		},

		/**
		 * Create span elements to display when the status bar tree or a message when the editor is in text mode
		 */
		addComponents: function () {
			// Word count
			var wordCount = document.createElement('span');
			wordCount.id = this.editorId + '-statusBarWordCount';
			wordCount.style.display = 'block';
			wordCount.innerHTML = '&nbsp;';
			Dom.addClass(wordCount, 'statusBarWordCount');
			this.statusBarWordCount = this.getEl().dom.appendChild(wordCount);
			// Element tree
			var tree = document.createElement('span');
			tree.id = this.editorId + '-statusBarTree';
			tree.style.display = 'block';
			tree.innerHTML = HTMLArea.localize('Path') + ': ';
			Dom.addClass(tree, 'statusBarTree');
			this.statusBarTree = this.getEl().dom.appendChild(tree);
			// Text mode
			var textMode = document.createElement('span');
			textMode.id = this.editorId + '-statusBarTextMode';
			textMode.style.display = 'none';
			textMode.innerHTML = HTMLArea.localize('TEXT_MODE');
			Dom.addClass(textMode, 'statusBarTextMode');
			this.statusBarTextMode = this.getEl().dom.appendChild(textMode);
		},

		/**
		 * Clear the status bar tree
		 */
		clear: function () {
			var node = this.statusBarTree.firstChild;
			while (node) {
				if (/^(a)$/i.test(node.nodeName)) {
					var extNode = Ext.get(node);
					extNode.removeAllListeners();
					Ext.QuickTips.unregister(extNode);
					extNode.dom = null;
				}
				var nextNode = node.nextSibling;
				Dom.removeFromParent(node);
				var node = nextNode;
			}
			this.setSelection(null);
		},

		/**
		 * Flag indicating that the status bar should not be updated on this toolbar update
		 */
		noUpdate: false,

		/**
		 * Update the status bar
		 */
		onUpdateToolbar: function (mode, selectionEmpty, ancestors, endPointsInSameBlock) {
			if (mode === 'wysiwyg' && !this.noUpdate) {
				var text,
					language,
					languageObject = this.getEditor().getPlugin('Language'),
					classes = new Array(),
					classText;
				this.clear();
				var path = document.createElement('span');
				path.innerHTML = HTMLArea.localize('Path') + ': ';
				path = this.statusBarTree.appendChild(path);
				var index, n, j, m;
				for (index = 0, n = ancestors.length; index < n; index++) {
					var ancestor = ancestors[index];
					if (!ancestor) {
						continue;
					}
					text = ancestor.nodeName.toLowerCase();
					// Do not show any id generated by ExtJS
					if (ancestor.id && text !== 'body' && ancestor.id.substr(0, 7) !== 'ext-gen') {
						text += '#' + ancestor.id;
					}
					if (languageObject && languageObject.getLanguageAttribute) {
						language = languageObject.getLanguageAttribute(ancestor);
						if (language != 'none') {
							text += '[' + language + ']';
						}
					}
					if (ancestor.className) {
						classText = '';
						classes = ancestor.className.trim().split(' ');
						for (j = 0, m = classes.length; j < m; ++j) {
							if (!HTMLArea.reservedClassNames.test(classes[j])) {
								classText += '.' + classes[j];
							}
						}
						text += classText;
					}
					var element = document.createElement('a');
					element.href = '#';
					element.setAttribute('ext:qtitle', HTMLArea.localize('statusBarStyle'));
					element.setAttribute('ext:qtip', ancestor.style.cssText.split(';').join('<br />'));
					element.innerHTML = text;
					element = path.parentNode.insertBefore(element, path.nextSibling);
					element.ancestor = ancestor;
					Ext.get(element).on('click', this.onClick, this);
					Ext.get(element).on('mousedown', this.onClick, this);
					if (!UserAgent.isOpera) {
						Ext.get(element).on('contextmenu', this.onContextMenu, this);
					}
					if (index) {
						var separator = document.createElement('span');
						separator.innerHTML = String.fromCharCode(0xbb);
						element.parentNode.insertBefore(separator, element.nextSibling);
					}
				}
			}
			this.updateWordCount();
			this.noUpdate = false;
		},

		/**
		 * Handler when the word count may have changed
		 */
		onWordCountChange: function(delay) {
			this.updateWordCountLater.delay(delay ? delay : 0);
		},

		/**
		 * Update the word count
		 */
		updateWordCount: function() {
			var wordCount = 0;
			if (this.getEditor().getMode() == 'wysiwyg') {
				// Get the html content
				var text = this.getEditor().getHTML();
				if (typeof text === 'string' && text.length > 0) {
					// Replace html tags with spaces
					text = text.replace(HTMLArea.RE_htmlTag, ' ');
					// Replace html space entities
					text = text.replace(/&nbsp;|&#160;/gi, ' ');
					// Remove numbers and punctuation
					text = text.replace(HTMLArea.RE_numberOrPunctuation, '');
					// Get the number of word
					wordCount = text.split(/\S\s+/g).length - 1;
				}
			}
			// Update the word count of the status bar
			this.statusBarWordCount.innerHTML = wordCount ? ( wordCount + ' ' + HTMLArea.localize((wordCount == 1) ? 'word' : 'words')) : '&nbsp;';
		},

		/**
		 * Adapt status bar to current editor mode
		 *
		 * @param	string	mode: the mode to which the editor got switched to
		 */
		onModeChange: function (mode) {
			switch (mode) {
				case 'wysiwyg':
					this.statusBarTextMode.style.display = 'none';
					this.statusBarTree.style.display = 'block';
					break;
				case 'textmode':
				default:
					this.statusBarTree.style.display = 'none';
					this.statusBarTextMode.style.display = 'block';
					break;
			}
		},

		/**
		 * Reference to the element last selected on the status bar
		 */
		selected: null,

		/**
		 * Get the status bar selection
		 */
		getSelection: function() {
			return this.selected;
		},

		/**
		 * Set the status bar selection
		 *
		 * @param	object	element: set the status bar selection to the given element
		 */
		setSelection: function (element) {
			this.selected = element ? element : null;
		},

		/**
		 * Select the element that was clicked in the status bar and set the status bar selection
		 */
		selectElement: function (element) {
			var editor = this.getEditor();
			element.blur();
			if (!UserAgent.isIEBeforeIE9) {
				if (/^(img|table)$/i.test(element.ancestor.nodeName)) {
					editor.getSelection().selectNode(element.ancestor);
				} else {
					editor.getSelection().selectNodeContents(element.ancestor);
				}
			} else {
				if (/^(img|table)$/i.test(element.ancestor.nodeName)) {
					var range = editor.document.body.createControlRange();
					range.addElement(element.ancestor);
					range.select();
				} else {
					editor.getSelection().selectNode(element.ancestor);
				}
			}
			this.setSelection(element.ancestor);
			this.noUpdate = true;
			editor.toolbar.update();
		},

		/**
		 * Click handler
		 */
		onClick: function (event, element) {
			this.selectElement(element);
			event.stopEvent();
			return false;
		},

		/**
		 * ContextMenu handler
		 */
		onContextMenu: function (event, target) {
			this.selectElement(target);
			return this.getEditor().getPlugin('ContextMenu') ? this.getEditor().getPlugin('ContextMenu').show(event, target.ancestor) : false;
		},

		/**
		 * Cleanup
		 */
		onBeforeDestroy: function() {
			this.clear();
			this.removeAll(true);
			this.statusBarTree = null;
			this.statusBarWordCount = null;
			return true;
		}
	});

	return StatusBar;

}(HTMLArea.UserAgent, HTMLArea.DOM);
Ext.reg('htmlareastatusbar', HTMLArea.StatusBar);
